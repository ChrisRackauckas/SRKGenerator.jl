#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{multicol} 
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\rightmargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Stability-Optimized High Order Methods and Stiffness Detection for Stochastic
 Differential Equations with Additive and Diagonal Noise
\end_layout

\begin_layout Author
Chris Rackauckas and Qing Nie
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Stochastic differential equations are being increasingly used in scientific
 fields such as biology and climate science due to their ability to capture
 the randomness inherent in physical systems.
 These equations are of the general form:
\begin_inset Formula 
\[
dX_{t}=f(t,X_{t})dt+g(t,X_{t})dW_{t}
\]

\end_inset

where 
\begin_inset Formula $X_{t}$
\end_inset

 is a 
\begin_inset Formula $d$
\end_inset

-dimensional vector, where 
\begin_inset Formula $f:\mathbb{R}^{d}\rightarrow\mathbb{R}^{d}$
\end_inset

 is the drift coefficient and 
\begin_inset Formula $g:\mathbb{R}^{d}\rightarrow\mathbb{R}^{d\times m}$
\end_inset

 is a matrix equation known as the diffusion coefficient which describes
 the amount and mixtures of the noise process 
\begin_inset Formula $W_{t}$
\end_inset

 which is a 
\begin_inset Formula $m$
\end_inset

-dimensional Brownian motion.
 In many models, noise is added to deterministic equations phenomenologically.
 These models are numerically studied for their qualitatative behavior:
 scientists are interested not in numerical predictions exact to many decimal
 places but to understand the phonomena which only occurs in the presence
 of stochasticity, like random switching between cell types.
 In these cases, the noise process can be modeled as exogenous to the system
 and thus not dependent the system itself, leading to the assumption that
 
\begin_inset Formula $g(t,X_{t})\equiv g(t)$
\end_inset

 which is known as additive noise.
 Another common case is multiplicative noise, where to each deterministic
 equation a noise term 
\begin_inset Formula $\sigma_{i}X_{t}^{i}dW_{t}$
\end_inset

 is added to give proportional noise.
 This results in 
\begin_inset Formula $g(t,X_{t})$
\end_inset

 being the diagonal matrix 
\begin_inset Formula $\left(\sigma_{i}X_{t}^{i}\right)$
\end_inset

 and thus falling into the more general category of diagonal noise.
\end_layout

\begin_layout Standard
The unique features of stochastic models in many cases are pathwise-dependent.
 The mean of a chemical reaction network may stay at a constant steady state,
 but in the presence of randomness this may be switching between various
 states.
 These pathwise properties are of interest because they capture the effects
 which cannot be found in deterministic models.
 However, these same effects exhibit numerical difficulties.
 Almost by definition these features exist in the single trajectories of
 the random processes and thus must be controlled individually.
 These trajectories display large, transient and random switching behavior
 which in a given trajectory causes stochastic bursts of numerical stiffness,
 a phonomena which we will denote pathwise stiffness.
 In previous work, the authors have shown that by using adaptive timestepping
 a stochastic reaction network of 19 reactants is able to be solve with
 an average timestep 100,000x larger than the value that was found necessary
 for stability during the random stiff events.
 However, the methods were still largely 
\begin_inset Quotes eld
\end_inset

stability-bound
\begin_inset Quotes erd
\end_inset

, that is the tolerance was set to solve the model was determined by what
 was necessary for stability but was far below the error necessary for the
 application.
 The purpose of this investigation is to develop numerical methods with
 the ability to properly handle pathwise stiffness and allow for efficient
 solving of large Monte Carlo experiments.
 We approach this through two means.
 On one end we develop stability-optimized Stochastic Runge-Kutta (SRK)
 methods which have the property of having drastically enlarged stability
 regions.
 Similar to the Runge-Kutta Chebyschev (and the S-ROCK extension to the
 stochastic case), these methods are designed to be efficient for equations
 which display stiffness without fully commiting to implicit solvers.
 On the otherhand, to handle extreme stiffness we develop implicit RK methods
 for additive noise SDEs.
 We extend the definition of L-stability to additive noise SDEs and develop
 two methods: a fully implicit 2-stage L-stable method and an extension
 of the a well-known L-stable explicit first stage singly diagonally implicit
 RK (ESDIRK) method due to Kennedy and Carpenter.
 To extend the utility of these methods, we derive an extension of the methods
 for additive SDEs to affine SDEs (mixed multiplicative and additive noise
 terms) through a transformation.
 In addition to the new methods, we display a novel scalable mechanism for
 the derivation of 
\begin_inset Quotes eld
\end_inset

optimal
\begin_inset Quotes erd
\end_inset

 Runge-Kutta methods, and use it to design stability-optimized methods for
 diagonal noise SDEs which would otherwise be analytically intractable due
 to the few million terms in the stability equation.
 In order to handle extreme transient stiffness, for each of these types
 of methods we derive methods for detecting stiffness and switching between
 implicit and explicit integrators in the presence of stiffness.
 Lastly, we show that on test problems that these methods are no less efficient
 than existing SRK methods when one only requires a few decimal places of
 accuracy (
\begin_inset Formula $>10^{-6}$
\end_inset

), but show that these methods have two to three times the stability region,
 allowing them to speed up computations on stability-bound problems by around
 10x.
\end_layout

\begin_layout Section
Adaptive Strong Order 1.0/1.5 SRK Methods
\end_layout

\begin_layout Standard
The class of methods we wish to example are the Strong Order 1.5 SRK methods
 due to Rossler (cite).
 The diagonal noise methods utilize the same general form and order conditions
 as the methods for scalar noise so we use their notation for simplicity.
 The strong order 1.5 methods for scalar noise are of the form
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
X_{n+1}=X_{n}+\sum_{i=1}^{s}\alpha_{i}f\left(t_{n}+c_{i}^{(0)}h,H_{i}^{(0)}\right)+\sum_{i=1}^{s}\left(\beta_{i}^{(1)}I_{(1)}+\beta_{i}^{(2)}\frac{I_{(1,1)}}{\sqrt{h}}+\beta_{i}^{(3)}\frac{I_{(1,0)}}{h}+\beta_{i}^{(4)}\frac{I_{(1,1,1)}}{h}\right)g\left(t_{n}+c_{i}^{(1)}h\right)\label{eq:update}
\end{equation}

\end_inset

 with stages
\begin_inset Formula 
\begin{align}
H_{i}^{(0)} & =X_{n}+\sum_{j=1}^{s}A_{ij}^{(0)}f\left(t_{n}+c_{j}^{(0)}h,H_{j}^{(0)}\right)h+\sum_{j=1}^{s}B_{ij}^{(0)}g\left(t_{n}+c_{j}^{(1)}h,H_{j}^{(1)}\right)\frac{I_{(1,0)}}{h}\label{eq:stages}\\
H_{i}^{(1)} & =X_{n}+\sum_{j=1}^{s}A_{ij}^{(1)}f\left(t_{n}+c_{j}^{(0)}h,H_{j}^{(0)}\right)h+\sum_{j=1}^{s}B_{ij}^{(1)}g\left(t_{n}+c_{j}^{(1)}h,H_{j}^{(1)}\right)\sqrt{h}\nonumber 
\end{align}

\end_inset

 where the 
\begin_inset Formula $I_{j}$
\end_inset

 are the Wiktorsson approximations to the iterated stochastic integrals
 (cite).
 In the case of additive noise, this reduces to the form
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
X_{n+1}=X_{n}+\sum_{i=1}^{s}\alpha_{i}f\left(t_{n}+c_{i}^{(0)}h,H_{i}^{(0)}\right)+\sum_{i=1}^{s}\left(\beta_{i}^{(1)}I_{(1)}+\beta_{i}^{(2)}\frac{I_{(1,0)}}{h}\right)g\left(t_{n}+c_{i}^{(1)}h\right)\label{eq:add_update}
\end{equation}

\end_inset

 with stages
\begin_inset Formula 
\begin{equation}
H_{i}^{(0)}=X_{n}+\sum_{j=1}^{s}A_{ij}^{(0)}f\left(t_{n}+c_{j}^{(0)}h,H_{j}^{(0)}\right)h+\sum_{j=1}^{s}B_{ij}^{(0)}g\left(t_{n}+c_{j}^{(1)}h\right)\frac{I_{(1,0)}}{h}.\label{eq:add_stages}
\end{equation}

\end_inset

 The tuple of coefficients 
\begin_inset Formula $\left(A^{(j)},B^{(j)},\beta^{(j)},\alpha\right)$
\end_inset

 thus fully determine the SRK method.
 These coefficients must satisfy the constraint equations described in Appendix
 X in order to receive strong order 1.5.
 Rackauckas and Nie constructed a systematic method for developing an embedded
 strong order 1.0 method from any SRK tableau and showed that adaptive timesteppi
ng using this estimator is fundamental for the efficient simulation of pathwise
 stiff models.
 Thus unlike in the theory of ordinary differential equations, the choice
 of coefficients for SRK methods does not require explicitly finding an
 embedded method when developing an adaptive SRK method and we will therefore
 take for granted that each of the derived methods is adaptive in time.
\end_layout

\begin_layout Section
Optimized-Stability High Order SRK Methods with Additive Noise
\end_layout

\begin_layout Standard
Using the terms as defined by Kloden and Platen (cite), we define a discrete
 approximation as numerically stable if for any finite time interval 
\begin_inset Formula $\left[t_{0},T\right]$
\end_inset

, there exists a positive constant 
\begin_inset Formula $\Delta_{0}$
\end_inset

 such that for each 
\begin_inset Formula $\epsilon>0$
\end_inset

 and each 
\begin_inset Formula $\delta\in\left(0,\Delta_{0}\right)$
\end_inset

 
\begin_inset Formula 
\begin{equation}
\lim_{\left|X_{0}^{\delta}-\bar{X}_{0}^{\delta}\right|\rightarrow0}\sup_{t_{0}\leq t\leq T}P\left(\left|X_{t}^{\delta}-\bar{X}_{t}^{\delta}\right|\geq\epsilon\right)=0\label{eq:add_stab}
\end{equation}

\end_inset

 where 
\begin_inset Formula $X_{n}^{\delta}$
\end_inset

 is a discrete time approximation with maximum step size 
\begin_inset Formula $\delta>0$
\end_inset

 starting at 
\begin_inset Formula $X_{0}^{\delta}$
\end_inset

 and 
\begin_inset Formula $\bar{X}_{n}^{\delta}$
\end_inset

 respectively starting at 
\begin_inset Formula $\bar{X}_{n}^{\delta}$
\end_inset

.
 For additive noise, we consider the complex-valued linear test equations
\begin_inset Formula 
\begin{equation}
dX_{t}=\mu X_{t}dt+dW_{t}\label{eq:add_test}
\end{equation}

\end_inset

 where 
\begin_inset Formula $\lambda$
\end_inset

 is a complex number.
 In this framework, a scheme which can be written in the form 
\begin_inset Formula 
\begin{equation}
X_{n+1}^{h}=X_{n}^{h}G\left(\mu h\right)+Z_{n}^{\delta}\label{eq:add_test_2}
\end{equation}

\end_inset

with a constant step size 
\begin_inset Formula $\delta\equiv h$
\end_inset

 and 
\begin_inset Formula $Z_{n}^{\delta}$
\end_inset

 are random variables which do not depend on the 
\begin_inset Formula $Y_{n}^{\delta}$
\end_inset

, then the region of absolute stability is the set where for 
\begin_inset Formula $z=\mu h$
\end_inset

, 
\begin_inset Formula $\left|G(z)\right|<1$
\end_inset

.
 
\end_layout

\begin_layout Standard
The additive SRK method can be written as
\begin_inset Formula 
\begin{equation}
X_{n+1}^{h}=X_{n}^{h}+z\left(\alpha\cdot H^{(0)}\right)+\beta^{(1)}\sigma I_{(1)}+\sigma\beta^{(2)}\frac{I_{(1,0)}}{h}\label{eq:SRK_stab_step1}
\end{equation}

\end_inset

 where
\begin_inset Formula 
\begin{equation}
H^{(0)}=\left(I-zA^{(0)}\right)^{-1}\left(\hat{X_{n}^{h}}+B^{(0)}e\sigma\frac{I_{(1,0)}}{h}\right)\label{eq:SRK_stab_step}
\end{equation}

\end_inset

where 
\begin_inset Formula $\hat{X_{n}^{h}}$
\end_inset

 is the size 
\begin_inset Formula $s$
\end_inset

 constant vector of elements 
\begin_inset Formula $X_{n}^{h}$
\end_inset

 and 
\begin_inset Formula $e=\left(1,1,1,1\right)^{T}$
\end_inset

.
 By substitution we receive
\begin_inset Formula 
\begin{equation}
X_{n+1}^{h}=X_{n}^{h}\left(1+z\left(\alpha\cdot\left(I-zA^{(0)}\right)^{-1}\right)\right)+\left(I-zA^{(0)}\right)^{-1}B^{(0)}e\sigma\frac{I_{(1,0)}}{h}+\beta^{(1)}\sigma I_{(1)}+\sigma\beta^{(2)}\frac{I_{(1,0)}}{h}\label{eq:SRK_stab_sub}
\end{equation}

\end_inset

This set of equations decouples to the form of Equation ## since the iterated
 stochastic integral approximation 
\begin_inset Formula $I_{j}$
\end_inset

 are random numbers and are independent of the 
\begin_inset Formula $X_{n}^{h}$
\end_inset

.
 Thus the stability condition is determined by the equation
\begin_inset Formula 
\begin{equation}
G(z)=1+z\alpha\cdot\left(I-zA^{(0)}\right)^{-1}\label{eq:SRA_stab}
\end{equation}

\end_inset

which one may notice is the stability equation of the drift tableau applied
 to a deterministic ODE.
 Thus the stability properties of the deterministic Runge-Kutta methods
 carry over to the additive noise SRA methods on this test equation.
 However, most two-stage tableaus were developed to satisfy higher order
 deterministic order constraints which do not apply.
 We will instead look to maximize stability while satisfying the stochastic
 order constraints.
\end_layout

\begin_layout Subsection
Explicit Methods for Non-Stiff SDEs with Additive Noise
\end_layout

\begin_layout Subsubsection
Stability-Optimal 2-Stage Explicit SRA Methods
\end_layout

\begin_layout Standard
For explicit methods, the 
\begin_inset Formula $A^{(i)}$
\end_inset

 and 
\begin_inset Formula $B^{(i)}$
\end_inset

 are lower diagonal and we receive the simplified stability function 
\begin_inset Formula 
\begin{equation}
G(z)=1+A_{21}z^{2}\alpha_{2}+z\left(\alpha_{1}+\alpha_{2}\right)\label{eq:SRA_stab_2}
\end{equation}

\end_inset

 for a two-stage additive noise SRK method.
 For this method we will find the method which optimizes the stability in
 the real part of 
\begin_inset Formula $z$
\end_inset

.
 Thus we wish to find 
\begin_inset Formula $A^{(0)}$
\end_inset

 and 
\begin_inset Formula $\alpha$
\end_inset

 s.t.
 the negative real roots of 
\begin_inset Formula $\left|G(z)\right|=1$
\end_inset

 are minimized.
 By the quadratic equation we see that there exists only a single negative
 root: 
\begin_inset Formula $z=\frac{1-\sqrt{1+8\alpha_{2}}}{2\alpha_{2}}$
\end_inset

.
 Using Mathematica's minimum function, we determine that the minimum value
 for this root subject to the order constraints is 
\begin_inset Formula $z=\frac{3}{4}\left(1-\sqrt{\frac{19}{3}}\right)\approx-1.13746$
\end_inset

.
 This is achieved when 
\begin_inset Formula $\alpha=\frac{2}{3}$
\end_inset

, meaning that the SRA1 method due to Rossler achieves the maximum stability
 criteria.
 However, given extra degrees of freedom, we attempted to impose that 
\begin_inset Formula $c_{1}^{(0)}=c_{1}^{(1)}=0$
\end_inset

 and 
\begin_inset Formula $c_{2}^{(0)}=c_{2}^{(1)}=1$
\end_inset

 so that the error estimator spans the whole interval.
 This can lead to improved robustness of the adaptive error estimator.
 In fact, when trying to optimize the error estimator's span we find that
 there is no error estimator which satisfies 
\begin_inset Formula $c_{2}^{(0)}>\frac{3}{4}$
\end_inset

 which is the span of the SRA1 method.
 Thus the SRA1 is the stability-optimized 2-stage explicit method which
 achieves the most robust error estimator.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
A^{(0)} & =\left(\begin{array}{cc}
0 & 0\\
\frac{3}{4} & 0
\end{array}\right),\thinspace\thinspace\thinspace B^{(0)}=\left(\begin{array}{cc}
0 & 0\\
\frac{3}{2} & 0
\end{array}\right),\thinspace\thinspace\thinspace\thinspace\alpha=\left(\begin{array}{c}
\frac{1}{3}\\
\frac{2}{3}
\end{array}\right)\nonumber \\
\beta^{(1)} & =\left(\begin{array}{c}
1\\
0
\end{array}\right),\thinspace\thinspace\thinspace\beta^{(2)}=\left(\begin{array}{c}
-1\\
1
\end{array}\right),\thinspace\thinspace\thinspace c^{(0)}=\left(\begin{array}{c}
0\\
\frac{3}{4}
\end{array}\right),\,\,\,c^{(1)}=\left(\begin{array}{c}
1\\
0
\end{array}\right)\label{eq:SRA1}
\end{align}

\end_inset


\end_layout

\begin_layout Subsubsection
Stability-Optimal 3-Stage Explicit SRA Methods
\end_layout

\begin_layout Standard
For the 3-stage SRA method, we recieve the simplified stability function
\begin_inset Formula 
\begin{equation}
G(z)=A_{21}A_{31}\alpha_{3}z^{3}+A_{21}\alpha_{2}z^{2}+A_{31}\alpha_{3}z^{2}+A_{32}\alpha_{3}z^{2}+\alpha_{1}z+\alpha_{2}z+\alpha_{3}z+1\label{eq:SRA_stab_3}
\end{equation}

\end_inset

 To optimize this method, we attempted to use the same techniques as before
 and optimize the real values of the negative roots.
 However, in this case we have a cubic polynomial and the root equations
 are more difficult.
 Instead, we turn to a more general technique to handle the stability optimizati
on which will be employed in later sections as well.
 To do so, we generate an optimization problem which we can numerically
 solve for the coefficients.
 To simplify the problem, we let 
\begin_inset Formula $z\in\mathbb{R}$
\end_inset

.
 Define the function:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
f\left(z,w;N,M\right)=\int_{D}\chi_{G(z)\leq1}(z)dz\label{eq:SRA_integral}
\end{equation}

\end_inset

Notice that for 
\begin_inset Formula $D\rightarrow\mathbb{C}$
\end_inset

, 
\begin_inset Formula $f$
\end_inset

 is the area of the stability region.
 Thus we define the stability-optimized SRK method for additive noise SDEs
 as the set of coefficients which achieves
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\max_{A^{(i)},B^{(i)},\beta^{(i)},\alpha} & f(z)\label{eq:SRA_maximize}\\
\text{subject to: } & \text{Order Constraints}\nonumber 
\end{align}

\end_inset

In all cases we impose 
\begin_inset Formula $0<c_{i}^{(0)},c_{i}^{(1)}<1$
\end_inset

.
 We use the order constraints to simplify the problem to an nonlinear optimizati
on problem on 14 variables with 3 equality constraints and 4 inequality
 constraints (with bound constraints on the 10 variables).
 However, we found that simplifying the problem even more to require 
\begin_inset Formula $c_{1}^{(0)}=c_{1}^{(1)}=0$
\end_inset

 and 
\begin_inset Formula $c_{3}^{(0)}=c_{3}^{(1)}=1$
\end_inset

 did not significantly impact the stability regions but helps the error
 estimator and thus we reduced the problem to 10 variables, 3 equality constrain
ts, and 2 inequality constraints.
 This was optimized using the COBYLA local optimization algorithm with randomize
d initial conditions 100 times and all gave similar results.
 In the Mathematica notebook we show the effect of changing the numerical
 integration region 
\begin_inset Formula $D$
\end_inset

 on the results, but conclude that a 
\begin_inset Formula $D$
\end_inset

 which does not bias the result for better/worse real/complex handling does
 not improve the result.
 The resulting algorithm, SOSRA, we given by the coefficients in Table X
 in the appendix.
 Lastly, we used the condition that 
\begin_inset Formula $c_{2}^{(0)}=c_{3}^{(0)}=c_{2}^{(1)}=c_{3}^{(1)}=1$
\end_inset

 to allow for free stability detection (discussed in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:StabilityDetection"

\end_inset

).
 The method generated with this extra constraint is SOSRA2.
 These methods have their stability regions compared to SRA1 and SRA3 in
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:SOSRA-Stability-Regions."

\end_inset

 where it is shown that the SOSRA methods more than doubles the allowed
 timesteps when the eigenvalues of the Jacobian are dominated by the real
 part.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/Chris/.julia/v0.6/SRKGenerator/assets/obj_poly_solve/SOSRA_stability.pdf

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
SOSRA Stability Regions.
 The stability regions (
\begin_inset Formula $\left|G(z)\right|<1$
\end_inset

) are plotted in the 
\begin_inset Formula $(x,y)$
\end_inset

-plane for 
\begin_inset Formula $z=x+iy$
\end_inset

.
 Shown are the SRA methods SRA1 and SRA3 in addition to the SOSRA and SOSRA2
 methods.
 Note that SOSRA and SOSRA2 have nearly identical stability regions, making
 it hard to decern the two in the plot.
\begin_inset CommandInset label
LatexCommand label
name "fig:SOSRA-Stability-Regions."

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Drift Implicit Methods for Stiff SDEs with Additive Noise
\end_layout

\begin_layout Subsubsection
An L-Stable 2-Stage (Semi-)Implicit SRA Method
\end_layout

\begin_layout Standard
It's clear that, as in the case for deterministic equations, the explicit
 methods cannot be made A-stable.
 However, the implicit two-stage additive noise SRK method is determined
 by
\begin_inset Formula 
\begin{equation}
G(z)=\frac{z(A_{11}(A_{22}z-\alpha_{2}z-1)+A_{12}z(\alpha_{1}-A_{21})+A_{21}\ensuremath{\alpha_{2}}z-A_{22}(\alpha_{1}z+1)+\alpha_{1}+\alpha_{2})+1}{A_{11}z(A_{22}z-1)-z(A_{12}A_{21}z+A_{22})+1}\label{eq:SRA_stab2_implicit}
\end{equation}

\end_inset

 which is 
\begin_inset Formula $A$
\end_inset

-stable if 
\begin_inset Formula 
\begin{equation}
A_{11}z(A_{22}z-1)-z(A_{12}A_{21}z+A_{22})+1>z(A_{11}(A_{22}z-\alpha_{2}z-1)+A_{12}z(\alpha_{1}-A_{21})+A_{21}\ensuremath{\alpha_{2}}z-A_{22}(\alpha_{1}z+1)+\alpha_{1}+\alpha_{2})+1.\label{eq:SRA_stab2_ineq}
\end{equation}

\end_inset

 Notice that the numerator equals the denominator if and only if 
\begin_inset Formula $z=0$
\end_inset

 or
\begin_inset Formula 
\begin{equation}
z=\frac{\alpha_{1}+\alpha_{2}}{\left(A_{22}-A_{12}\right)\alpha_{1}+\left(A_{11}-A_{21}\right)\alpha_{2}}.\label{eq:SRA_stab2_z}
\end{equation}

\end_inset

From the order conditions we know that 
\begin_inset Formula $\alpha_{1}+\alpha_{2}=1$
\end_inset

 which means that no root exists with 
\begin_inset Formula $Re(z)<0$
\end_inset

 if 
\begin_inset Formula $\left(A_{22}-A_{12}\right)\alpha_{1}+\left(A_{11}-A_{21}\right)\alpha_{2}>0$
\end_inset

.
 Thus under these no roots conditions, we can determine A-stability by checking
 the inequality at 
\begin_inset Formula $z=1$
\end_inset

, which gives 
\begin_inset Formula $1>\left(A_{22}-A_{12}\right)\alpha_{1}+\left(A_{11}-A_{21}\right)\alpha_{2}$
\end_inset

.
 Using the order condition, we have a total of four constraints on the 
\begin_inset Formula $A^{(0)}$
\end_inset

 and 
\begin_inset Formula $\alpha$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\left(A_{11}+A_{12}\right)\alpha_{1}+\left(A_{21}+A_{22}\right)\alpha_{2} & =\frac{1}{2}\label{eq:SRA_stab2_conds}\\
\alpha_{1}+\alpha_{2} & =1\nonumber \\
0<\left(A_{22}-A_{12}\right)\alpha_{1}+\left(A_{11}-A_{21}\right)\alpha_{2} & <1\nonumber 
\end{align}

\end_inset

However, A-stability is not sufficient for most ODE integrators to properly
 handle stiff equations and thus extra properties generally imposed.
 One important property we wish to extend to stochastic integrators is L-stabili
ty.
 The straightforward extension of L-stability is the condition
\begin_inset Formula 
\begin{equation}
\lim_{z\rightarrow\infty}G(z)=0.\label{eq:SRA_L}
\end{equation}

\end_inset

This implies that
\begin_inset Formula 
\begin{equation}
\frac{-A_{11}A_{22}+A_{11}\alpha_{2}+A_{12}A_{21}-A_{12}\alpha_{1}-A_{21}\alpha_{2}+A_{22}\alpha_{2}\alpha_{1}}{A_{12}A_{21}-A_{11}A_{22}}=0\label{eq:SRA_Lcond}
\end{equation}

\end_inset

 The denominator is 
\begin_inset Formula $-\det(A^{(0)})$
\end_inset

 which implies 
\begin_inset Formula $A^{(0)}$
\end_inset

 must be non-singular.
 Next, we attempt to impose B-stability on the drift portion of the method.
 We use the condition due to Burrage and Butcher that for 
\begin_inset Formula $B=\text{diag}\left(\alpha_{1},\alpha_{2}\right)$
\end_inset

 
\begin_inset Formula $M=BA^{(0)}+A^{(0)}B-\alpha\alpha^{T}$
\end_inset

, we require both 
\begin_inset Formula $B$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 to be non-negative definite.
 However, in the supplemental Mathematica notebooks we show computationally
 that there is no 2-stage SRK method of this form which satisfies all three
 of these stability conditions.
 Thus we settle for A-stability and L-stability.
\end_layout

\begin_layout Standard
Recalling that 
\begin_inset Formula $c^{(0)}$
\end_inset

 and 
\begin_inset Formula $c^{(1)}$
\end_inset

 are the locations in time where 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 are approximated respectively, we wish to impose
\begin_inset Formula 
\begin{align}
c_{1}^{(0)} & =0\label{eq:SRA_ccond}\\
c_{2}^{(0)} & =1\nonumber \\
c_{1}^{(1)} & =0\nonumber \\
c_{2}^{(1)} & =1\nonumber 
\end{align}

\end_inset

 so that the error estimator covers the entire interval of integration (for
 robustness to discontinuities).
 Since 
\begin_inset Formula $c^{(0)}=A^{(0)}e$
\end_inset

, this leads to the condition 
\begin_inset Formula $A_{21}+A_{22}=1$
\end_inset

.
 Using the constraint-satisfaction algorithm FindInstance in Mathematica,
 we look for tableaus which satisfy the previous conditions with the added
 constraint of semi-implicitness, i.e.
 
\begin_inset Formula $B^{(0)}$
\end_inset

 is lower triangular.
 This assumption is added becaues the inverse of the normal distribution
 has unbounded moments, and thus in many cases it mathematically simpler
 to consider the diffusion term as explicit (though there are recent methods
 which drop this requirement via truncation or extra assumptions on the
 solution).
 However, we find that there is no coefficient set which meets all of these
 requirements.
 However, if we relax the interval estimate condition to allow 
\begin_inset Formula $0\leq c_{2}^{(0)}\leq1$
\end_inset

, we find an A-L stable method:
\begin_inset Formula 
\begin{align}
A^{(0)} & =\left(\begin{array}{cc}
-1 & 1\\
0 & \frac{3}{4}
\end{array}\right),\thinspace\thinspace\thinspace B^{(0)}=\left(\begin{array}{cc}
0 & 0\\
\frac{3}{2} & 0
\end{array}\right),\thinspace\thinspace\thinspace\thinspace\alpha=\left(\begin{array}{c}
\frac{1}{3}\\
\frac{2}{3}
\end{array}\right)\label{eq:LSRA}\\
\beta^{(1)} & =\left(\begin{array}{c}
0\\
1
\end{array}\right),\thinspace\thinspace\thinspace\beta^{(2)}=\left(\begin{array}{c}
1\\
-1
\end{array}\right),\thinspace\thinspace\thinspace c^{(0)}=\left(\begin{array}{c}
0\\
\frac{3}{4}
\end{array}\right),\,\,\,c^{(1)}=\left(\begin{array}{c}
0\\
1
\end{array}\right)\nonumber 
\end{align}

\end_inset

which we denote LSRA.
 If we attempt to look for a 2-stage SDIRK-like method to reduce the complexity
 of the implicit equation, i.e.
 
\begin_inset Formula $A_{12}^{(0)}=0$
\end_inset

, using FindInstance we find the constraints unsatisfiable.
 Note that if we drop the semi-implicit assumption we find that the full
 constraints cannot be satisfied there (we still cannot satisfy 
\begin_inset Formula $c_{1}^{(0)}=0$
\end_inset

 and 
\begin_inset Formula $c_{2}^{(0)}=1$
\end_inset

), and there does not exist an A-L stable SDIRK method in that case.
\end_layout

\begin_layout Subsubsection
Extensions of ODE Implicit Runge-Kutta Methods to Implicit SRA Methods
\end_layout

\begin_layout Standard
Since the stability region of the SRA methods is completely determined by
 the deterministic portion 
\begin_inset Formula $A^{(0)}$
\end_inset

, in some cases there may exist a sensible extension of implicit Runge-Kutta
 methods for ordinary differential equations to high order adaptive methods
 stochastic differential equations with additive noise which keep the same
 stability properties.
 Since the order constraints which only involve the deterministic portions
 
\begin_inset Formula $A^{(0)}$
\end_inset

, 
\begin_inset Formula $c^{(0)}$
\end_inset

, and 
\begin_inset Formula $\alpha$
\end_inset

 match the conditions required for ODE integrators, existance is dependent
 on finding 
\begin_inset Formula $\beta^{(1)}$
\end_inset

, 
\begin_inset Formula $\beta^{(2)}$
\end_inset

, 
\begin_inset Formula $c^{(1)}$
\end_inset

, and 
\begin_inset Formula $B^{(0)}$
\end_inset

 that satisfy the full order constraints.
 In this case, an adaptive error estimator can be added by using the same
 estimator as the ODE method (which we call 
\begin_inset Formula $E_{D}$
\end_inset

) but adding the absolute size of the stochastic portions 
\begin_inset Formula 
\begin{equation}
E_{N}=\left|\sum_{i=1}^{s}\left(\beta_{i}^{(1)}I_{(1)}+\beta_{i}^{(2)}\frac{I_{(1,0)}}{h}\right)\right|\label{eq:EN}
\end{equation}

\end_inset

 leading to the error estimator
\begin_inset Formula 
\begin{equation}
E=\delta E_{D}+E_{N}.\label{eq:E}
\end{equation}

\end_inset

This can be shown similarly to the construction in (Rackauckas and Nie 2017).
 Given the large literature on implicit RK methods for ODEs, this presents
 a large pool of possibly good methods and heuristically one may believe
 that these would do very well in the case of small noise.
 
\end_layout

\begin_layout Standard
However, we note that there does not always exist such an extension.
 Using the constraint-satisfaction algorithm FindInstance in Mathematica,
 we looked for extensions of the explicit first stage signly-diagonally
 implicit RK (ESDIRK) method TRBDF2 and could not find values satisfying
 the constraints.
 In addition, we could not find values for an extension of the 5th order
 Radau IIA method which satisfies the constraints.
 In fact, our computational search could not find any extension of a 3-stage
 L-stable implicit RK method which satisfies the constraints.
 
\end_layout

\begin_layout Standard
But, the 4-stage 3rd order ODE method due to Kennedy and Carpenter (cite)
 can be extended to the following:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
A^{(0)} & =\left(\begin{array}{cccc}
0 & 0 & 0 & 0\\
\frac{1767732205903}{4055673282236} & \frac{1767732205903}{4055673282236} & 0 & 0\\
\frac{2746238789719}{10658868560708} & -\frac{640167445237}{6845629431997} & \frac{1767732205903}{4055673282236} & 0\\
\frac{1471266399579}{7840856788654} & -\frac{4482444167858}{7529755066697} & \frac{11266239266428}{11593286722821} & \frac{1767732205903}{4055673282236}
\end{array}\right),\label{eq:KenCarp4}\\
B_{2,1}^{(0)} & =\frac{\frac{87294609440832483406992237\left(-53983406399371387722712393713535786276-26826820\sqrt{6853072660943221216270384658311461343029149665543510113394397}\right)}{4868738516734691891458097}-354038415192410790619483213666362001932}{210758174113231167877981435258781706648},\nonumber \\
B_{4,3}^{(0)} & =\frac{-53983406399371387722712393713535786276-26826820\sqrt{6853072660943221216270384658311461343029149665543510113394397}}{8606625878152317177894269252900546591},\nonumber \\
B_{i,j}^{(0)} & =0\thinspace o.w.,\nonumber \\
\alpha & =\left(\begin{array}{c}
\frac{1471266399579}{7840856788654}\\
-\frac{4482444167858}{7529755066697}\\
\frac{11266239266428}{11593286722821}\\
\frac{1767732205903}{4055673282236}
\end{array}\right)\nonumber \\
\beta^{(1)} & =\left(\begin{array}{c}
0\\
0\\
0\\
1
\end{array}\right),\thinspace\thinspace\thinspace\beta^{(2)}=\left(\begin{array}{c}
1\\
0\\
0\\
-1
\end{array}\right),\thinspace\thinspace\thinspace c^{(0)}=\left(\begin{array}{c}
0\\
\frac{1767732205903}{4055673282236}\\
\frac{3}{5}\\
1
\end{array}\right),\,\,\,c^{(1)}=\left(\begin{array}{c}
0\\
0\\
0\\
1
\end{array}\right)\nonumber 
\end{align}

\end_inset

 (E)SDIRK methods are particularly interesting because these methods can
 be solved using a single factorization of the function of the Jacobian
 
\begin_inset Formula $I-\gamma dtJ$
\end_inset

 where 
\begin_inset Formula $J$
\end_inset

 is the Jacobian.
 Additionally, explicit handling of the noise term is similar to the Implicit-Ex
plicit (IMEX) form for additive Runge-Kutta methods in that it occurs by
 adding a single constant term to the Newton iterations in each stage, meaning
 it does not significantly increase the computational cost.
 One thing to note is that the method is that since the problem is additive
 noise the method is never implicit in the dependent variables in the noise
 part, so in theory this can also be extended with 
\begin_inset Formula $B^{(1)}$
\end_inset

 implicit as well (with convergence concerns due to the non-finite inverse
 moments of the Normal distribution, see (Kloden) for details).
\end_layout

\begin_layout Section
Optimized-Stability Methods for Multiplicative Noise via Transformation
\end_layout

\begin_layout Standard
Given the efficiency of the methods for additive noise, one method for developin
g efficient methods for more general noise processes is to use a transform
 of diagonal noise processes to additive noise.
 This transform is due to Lamperti, which states that the SDE of the form
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
dX_{t}=f(t,X_{t})dt+\sigma(t,X_{t})R(t)dW_{t}\label{eq:Lamperti}
\end{equation}

\end_inset

 where 
\begin_inset Formula $\sigma$
\end_inset

 a diagonal matrix with diagonal elements 
\begin_inset Formula $\sigma_{i}(t,X_{i,t})$
\end_inset

 has the transformation
\begin_inset Formula 
\begin{equation}
Z_{i,t}=\psi_{i}(t,X_{i,t})=\int\sigma_{i}^{-1}(x,t)dx\mid_{x=X_{i,t}}\label{eq:LampertiIntegral}
\end{equation}

\end_inset

which will result in an Ito process with the ith element given by
\begin_inset Formula 
\begin{equation}
dZ_{i,t}=\left(\frac{\partial}{\partial t}\psi_{i}(t,x)\mid_{x=\psi^{-1}(t,Z_{i,t})}+\frac{f_{i}(\psi^{-1}(t,Z_{t}),t)}{\frac{1}{2}\frac{\partial}{\partial x}\sigma_{i}\left(\psi_{i}^{-1}\left(t,Z_{i,t}\right)\right)}\right)dt+\sum_{j=1}^{n}r_{ij}(t)dw_{j,t}\label{eq:LampertiTransform}
\end{equation}

\end_inset

 with
\begin_inset Formula 
\begin{equation}
X_{t}=\psi^{-1}\left(t,Z_{t}\right).\label{eq:LampertiInv}
\end{equation}

\end_inset

 This is easily verified using Ito's Lemma.
 An example of such a transformation is multidimensional geometric Brownian
 motion, where 
\begin_inset Formula $A=diag(a_{1},a_{2})$
\end_inset

, 
\begin_inset Formula $\sigma=diag(X_{1},X_{2})$
\end_inset

, and 
\begin_inset Formula $R=r_{ij}$
\end_inset

.
 Then in this case, 
\begin_inset Formula $Z=\psi(X)=\log(X)$
\end_inset

 and
\begin_inset Formula 
\begin{equation}
d\left[\begin{array}{c}
Z_{1}\\
Z_{2}
\end{array}\right]=\left[\begin{array}{c}
a_{1}-\frac{1}{2}\left(r_{11}^{2}+r_{12}^{2}\right)\\
a_{2}-\frac{1}{2}\left(r_{21}^{2}+r_{22}^{2}\right)
\end{array}\right]dt+\left[\begin{array}{cc}
r_{11} & r_{12}\\
r_{21} & r_{22}
\end{array}\right]dW_{t}.\label{eq:AdditveLamperti}
\end{equation}

\end_inset

 This transformation requires that 
\begin_inset Formula $\sigma_{i}^{-1}(t,X_{i,t})$
\end_inset

 is one-to-one, and thus does not exist in general for diagonal noise.
 However, in the case of mixed multiplicative and additive noise (affine
 noise): 
\begin_inset Formula 
\begin{equation}
dX_{t}=f(t,X_{t})dt+\left(\sigma_{M}X_{t}+\sigma_{A}\right)dW_{t}\label{eq:LampertiAffine}
\end{equation}

\end_inset

 where 
\begin_inset Formula $\sigma$
\end_inset

 is a constant diagonal matrix, then 
\begin_inset Formula $\psi_{i}(t,X_{i,t})=\int\left(\frac{1}{x-\frac{\sigma_{A}}{\sigma_{M}}}\right)dx\mid_{x=X_{i,t}}=\log(X_{t}-\frac{\sigma_{A}}{\sigma_{M}})$
\end_inset

 and thus 
\begin_inset Formula 
\begin{align}
d\log\left(X_{t}-\frac{\sigma_{A}}{\sigma_{M}}\right) & =\tilde{f}(t,X_{t})dt+\sigma_{M}dW_{t}\label{eq:LampertiAffineSol}\\
\tilde{f}(t,X_{t}) & =\frac{1}{2}\frac{f(t,X_{t})}{X_{t}-\frac{\sigma_{A}}{\sigma_{M}}}\nonumber 
\end{align}

\end_inset

where the log and division are considered element-wise, and the subtraction
 is considered against the diagonal vector.
 Thus we can modify the additive SRK method to be in the form
\begin_inset Formula 
\begin{equation}
\log\left(X_{n+1}-\frac{\sigma_{A}}{\sigma_{M}}\right)=\log\left(X_{n}-\frac{\sigma_{A}}{\sigma_{M}}\right)+\sum_{i=1}^{s}\alpha_{i}\tilde{f}\left(t_{n}+c_{i}^{(0)}h,\exp\left(H_{i}^{(0)}\right)+\frac{\sigma_{A}}{\sigma_{M}}\right)+\sum_{i=1}^{s}\left(\beta_{i}^{(1)}I_{(1)}+\beta_{i}^{(2)}\frac{I_{(1,0)}}{h}\right)\label{eq:AffineStep}
\end{equation}

\end_inset

with stages
\begin_inset Formula 
\begin{equation}
H_{i}^{(0)}=\log\left(X_{n}-\frac{\sigma_{A}}{\sigma_{M}}\right)+\sum_{j=1}^{s}A_{ij}^{(0)}\tilde{f}\left(t_{n}+c_{j}^{(0)}h,\exp\left(H_{j}^{(0)}\right)+\frac{\sigma_{A}}{\sigma_{M}}\right)h+\sum_{j=1}^{s}B_{ij}^{(0)}\frac{I_{(1,0)}}{h}.\label{eq:AffineStep2}
\end{equation}

\end_inset

 Back-transforming this, we get
\begin_inset Formula 
\begin{equation}
X_{n+1}=\left(X_{n}-\frac{\sigma_{A}}{\sigma_{M}}\right)\exp\left(\sum_{i=1}^{s}\alpha_{i}\tilde{f}\left(t_{n}+c_{i}^{(0)}h,\exp\left(H_{i}^{(0)}\right)+\frac{\sigma_{A}}{\sigma_{M}}\right)+\sum_{i=1}^{s}\left(\beta_{i}^{(1)}I_{(1)}+\beta_{i}^{(2)}\frac{I_{(1,0)}}{h}\right)\right)+\frac{\sigma_{A}}{\sigma_{M}}\label{eq:AffineUpdate}
\end{equation}

\end_inset

 where the exponentiation is interpreted element-wise.
\end_layout

\begin_layout Section
Optimized-Stability Order 1.5 SRK Methods with Diagonal Noise
\end_layout

\begin_layout Subsection
The Stability Equation for Order 1.5 SRK Methods with Diagonal Noise
\end_layout

\begin_layout Standard
For diagonal noise, we will use the mean-square definition of stability.
 A method is mean-square stable if 
\begin_inset Formula $\lim_{n\rightarrow\infty}\mathbb{E}\left(\left|X_{n}\right|^{2}\right)=0$
\end_inset

 on the test equation
\begin_inset Formula 
\begin{equation}
dX_{t}=\mu X_{t}dt+\sigma X_{t}dW_{t}.\label{eq:multtest}
\end{equation}

\end_inset

In matrix form we can re-write our method as given by
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
X_{n+1}=X_{n}+\mu h\left(\alpha\cdot H^{(0)}\right)+\sigma I_{(1)}\left(\beta^{(1)}\cdot H^{(1)}\right)+\sigma\frac{I_{(1,1)}}{\sqrt{h}}\left(\beta^{(2)}\cdot H^{(1)}\right)+\sigma\frac{I_{(1,0)}}{h}\left(\beta^{(3)}\cdot H^{(1)}\right)+\sigma\frac{I_{(1,1,1)}}{h}\left(\beta^{(4)}\cdot H^{(1)}\right)\label{eq:matrix_method}
\end{equation}

\end_inset

with stages
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
H^{(0)} & = & X_{n}+\mu\Delta tA^{(0)}H^{(0)}+\sigma\frac{I_{(1,0)}}{h}B^{(0)}H^{(1)},\label{eq:matrix_stages}\\
H^{(1)} & = & X_{n}+\mu\Delta tA^{(1)}H^{(0)}+\sigma\sqrt{\Delta t}B^{(1)}H^{(1)}\nonumber 
\end{eqnarray}

\end_inset

where 
\begin_inset Formula $\hat{X_{n}}$
\end_inset

 is the size 
\begin_inset Formula $s$
\end_inset

 constant vector of 
\begin_inset Formula $X_{n}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
H^{(0)} & = & \left(I-hA^{(0)}\right)^{-1}\left(\hat{X_{n}}+\sigma\frac{I_{(1,0)}}{h}B^{(0)}H^{(1)}\right),\label{matrx_stages_solve}\\
H^{(1)} & = & \left(I-\sigma\sqrt{h}B^{(1)}\right)^{-1}\left(\hat{X_{n}}+\mu hA^{(1)}H^{(0)}\right)\nonumber 
\end{eqnarray}

\end_inset

By the derivation in the appendix, we receive the equation
\end_layout

\begin_layout Standard

\size tiny
\begin_inset Formula 
\begin{eqnarray}
S=E\left[\frac{U_{n+1}^{2}}{U_{n}^{2}}\right] & = & \{1+\mu ht\left(\alpha\cdot\left[\left(I-\mu\Delta tA^{(0)}-\mu\sigma I_{(1,0)}A^{(1)}B^{(0)}\left(I-\sigma\sqrt{h}B^{(1)}\right)^{-1}\right)^{-1}\left(I+\sigma\frac{I_{(1,0)}}{h}B^{(0)}\left(I-\sigma\sqrt{h}B^{(1)}\right)^{-1}\right)\right]\right)\label{eq:stability_solve}\\
 &  & +\sigma I_{(1)}\left(\beta^{(1)}\cdot\left[\left(I-\sigma\sqrt{h}B^{(1)}-\mu hA^{(1)}\left(I-\mu hA^{(0)}\right)^{-1}\sigma\frac{I_{(1,0)}}{h}B^{(0)}\right)^{-1}\left(I+\mu hA^{(1)}\left(I-\mu hA^{(0)}\right)^{-1}\right)\right]\right)\nonumber \\
 &  & +\sigma\frac{I_{(1,1)}}{\sqrt{h}}\left(\beta^{(2)}\cdot\left[\left(I-\sigma\sqrt{h}B^{(1)}-\mu hA^{(1)}\left(I-\mu hA^{(0)}\right)^{-1}\sigma\frac{I_{(1,0)}}{h}B^{(0)}\right)^{-1}\left(I+\mu hA^{(1)}\left(I-\mu hA^{(0)}\right)^{-1}\right)\right]\right)\nonumber \\
 &  & +\sigma\frac{I_{(1,0)}}{h}\left(\beta^{(3)}\cdot\left[\left(I-\sigma\sqrt{h}B^{(1)}-\mu hA^{(1)}\left(I-\mu hA^{(0)}\right)^{-1}\sigma\frac{I_{(1,0)}}{h}B^{(0)}\right)^{-1}\left(I+\mu hA^{(1)}\left(I-\mu hA^{(0)}\right)^{-1}\right)\right]\right)\nonumber \\
 &  & +\sigma\frac{I_{(1,1,1)}}{h}\left(\beta^{(4)}\cdot\left[\left(I-\sigma\sqrt{h}B^{(1)}-\mu hA^{(1)}\left(I-\mu hA^{(0)}\right)^{-1}\sigma\frac{I_{(1,0)}}{h}B^{(0)}\right)^{-1}\left(I+\mu hA^{(1)}\left(I-\mu hA^{(0)}\right)^{-1}\right)\right]\right)\}^{2}\nonumber 
\end{eqnarray}

\end_inset


\size default
We apply the substitutions from the Appendix and let
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
z & =\mu h,\label{eq:axis}\\
w & =\sigma\sqrt{h}.\nonumber 
\end{align}

\end_inset

In this space, 
\begin_inset Formula $z$
\end_inset

 is the stability variable for the drift term and 
\begin_inset Formula $w$
\end_inset

 is the stability in the diffusion term.
 Under this scaling 
\begin_inset Formula $\left(h,\sqrt{h}\right)$
\end_inset

, the equation becomes independent of 
\begin_inset Formula $h$
\end_inset

 and thus becomes a function 
\begin_inset Formula $S(z,w)$
\end_inset

 on the coefficients of the SRK method.
 The equation 
\begin_inset Formula $S(z,w)$
\end_inset

 in terms of its coefficients for explicit methods (
\begin_inset Formula $A^{(i)}$
\end_inset

 and 
\begin_inset Formula $B^{(i)}$
\end_inset

 lower diagonal) has millions of terms and is shown in the supplemental
 Mathematica notebook.
 Determination of the stability equation for the implicit methods was found
 to be computationally intractable and is an avenue for further research.
\end_layout

\begin_layout Subsection
An Optimization Problem for Determination of Coefficients
\end_layout

\begin_layout Standard
We wish to determine the coefficients for the additive and diagonal SRK
 methods which optimize the stability.
 To do so, we generate an optimization problem which we can numerically
 solve for the coefficients.
 To simplify the problem, we let 
\begin_inset Formula $z,w\in\mathbb{R}$
\end_inset

.
 Define the function
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
f\left(z,w;N,M\right)=\int_{-M}^{M}\int_{-N}^{1}\chi_{S(z,w)\leq1}(z,w)dzdw.\label{eq:SRIarea}
\end{equation}

\end_inset

Notice that for 
\begin_inset Formula $N,M\rightarrow\infty$
\end_inset

, 
\begin_inset Formula $f$
\end_inset

 is the area of the stability region.
 Thus we define the stability-optimized diagonal SRK method as the set of
 coefficients which achieves
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\max_{A^{(i)},B^{(i)},\beta^{(i)},\alpha} & f(z,w)\label{eq:opt}\\
\text{subject to: } & \text{Order Constraints}\nonumber 
\end{align}

\end_inset

 However, like with the SRK methods for additive noise, we impose a few
 extra constraints to add robustness to the error estimator.
 In all cases we impose 
\begin_inset Formula $0<c_{i}^{(0)},c_{i}^{(1)}<1$
\end_inset

 .
 Additionally we can prescribe 
\begin_inset Formula $c_{4}^{(0)}=c_{4}^{(1)}=1$
\end_inset

 which we call the End-C Constraint.
 Lastly, we can prescribe the ordering constraint 
\begin_inset Formula $c_{1}^{(j)}<c_{2}^{(j)}<c_{3}^{(j)}<c_{4}^{(j)}$
\end_inset

 which we denote as the Inequality-C Constraint.
 
\end_layout

\begin_layout Standard
The resulting problem is a nonlinear programming problem with 44 variables
 and 42-48 constraint equations.
 The objective function is the two-dimensional integral of a discontinuous
 function which is determined by a polynomial of in 
\begin_inset Formula $z$
\end_inset

 and 
\begin_inset Formula $w$
\end_inset

 with approximately 3 million coefficients.
 To numerically approximate this function, we calculated the characteristic
 function on a grid with even spacing 
\begin_inset Formula $dx$
\end_inset

 using a CUDA kernel and found numerical solutions to the optimization problem
 using the JuMP framework with the NLopt backend.
 A mixed approach using many solutions of the semi-local optimizer LN_AUGLAG_EQ
 and fewer solutions from the global optimizer GN_ISRES were used to approximate
 the optimality of solutions.
 Optimization was run many times in parallel until many results produced
 methods with similar optimiality, indicating that we were likely obtained
 values near the true minimum.
\end_layout

\begin_layout Standard
The parameters 
\begin_inset Formula $N$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 are the bounds on the stability region, but also represent a tradeoff between
 the stability in the drift and the stability in the diffusion.
 A method which is optimized when 
\begin_inset Formula $M$
\end_inset

 is small would be highly stable in the case of small noise, but would not
 be guaranteed to have good stability properties in the presence of large
 noise.
 Thus these parameters are knobs for tuning the algorithms for specific
 situations, and thus we solved the problem for different combinations of
 
\begin_inset Formula $N$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 to determine different algorithms for the different cases.
\end_layout

\begin_layout Subsection
Resulting Approximately-Optimal Methods
\end_layout

\begin_layout Standard
The coefficients generated for approximately-optimal methods fall into three
 categories.
 In one category we have the drift-dominated stability methods where large
 
\begin_inset Formula $N$
\end_inset

 and small 
\begin_inset Formula $M$
\end_inset

 was optimized.
 On the other end we have the diffusion-dominated stability methods where
 large 
\begin_inset Formula $M$
\end_inset

 and small 
\begin_inset Formula $N$
\end_inset

 was optimized.
 Then we have the mixed stability methods which used some mixed size choices
 for 
\begin_inset Formula $N$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

.
 As a baseline, we optimized the objective without constraints on the 
\begin_inset Formula $c_{i}$
\end_inset

 to see what the 
\begin_inset Quotes eld
\end_inset

best possible method
\begin_inset Quotes erd
\end_inset

 would be.
 When this was done with large 
\begin_inset Formula $N$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

, the resulting method, which we name SRIOpt1, has almost every value of
 
\begin_inset Formula $c$
\end_inset

 satisfy the constraints, but with 
\begin_inset Formula $c_{2}^{(0)}\approx-0.04$
\end_inset

 and 
\begin_inset Formula $c_{4}^{(0)}\approx3.75$
\end_inset

.
 To see if we could produce methods which were more diffusion-stable, we
 decreased 
\begin_inset Formula $N$
\end_inset

 to optimize more in 
\begin_inset Formula $w$
\end_inset

 but failed to produce methods with substantially enlarged diffusion-stability
 over SRIOpt1.
\end_layout

\begin_layout Standard
Adding only the inequality constraints on the 
\begin_inset Formula $c_{i}$
\end_inset

 and looking for methods for drift-dominated stability, we failed to produce
 methods whose 
\begin_inset Formula $c_{i}$
\end_inset

 estimators adequately covered the interval.
 Some of the results did produce stability regions simliar to SRIOpt1 but
 with 
\begin_inset Formula $c_{i}^{(0)}<0.5$
\end_inset

 which indicates the method could have problems with error estimation.
 When placing the equality constraints on the edge 
\begin_inset Formula $c_{i}$
\end_inset

, one method, which we label SRIOpt2, resulted in similar stability to SRIOpt1
 but satisfy the 
\begin_inset Formula $c_{i}$
\end_inset

 constraints.
 In addition, this method satisfies 
\begin_inset Formula $c_{3}^{(0)}=c_{4}^{(0)}=1$
\end_inset

 and 
\begin_inset Formula $c_{3}^{(1)}=c_{4}^{(1)}=1$
\end_inset

, a property whose use will be explained in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:StabilityDetection"

\end_inset

.
 The stability regions for these methods is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:SOSRI-Stability-Regions."

\end_inset

.
\end_layout

\begin_layout Standard
To look for more diffusion-stable methods, we dropped to 
\begin_inset Formula $N=6$
\end_inset

 to encourage the methods to expand the stability in the 
\begin_inset Formula $w$
\end_inset

-plane.
 However, we could not find a method whose stability region went substantially
 beyond 
\begin_inset Formula $\left[-2,2\right]$
\end_inset

 in 
\begin_inset Formula $w$
\end_inset

.
 This was further decreased to 
\begin_inset Formula $N=1$
\end_inset

 where methods still could not go substantially beyond 
\begin_inset Formula $\left|2\right|$
\end_inset

.
 Thus we were not able to obtain methods optimized for the diffusion-dominated
 case.
 This hard barrier was hit under many different constraint and objective
 setups and under thousands of optimization runs, indicating there might
 be a diffusion-stability barrier for explicit methods.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/Chris/.julia/v0.6/SRKGenerator/assets/solution_examples/DiagonalStability.pdf

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
SOSRI Stability Regions.
 The stability regions for the SOSRI methods are plotted in the 
\begin_inset Formula $(z,w)$
\end_inset

-plane.
 In addition, the regions for Euler-Maruyama, SRIW1, and SRIW2 are shown
 for comparison.
\begin_inset CommandInset label
LatexCommand label
name "fig:SOSRI-Stability-Regions."

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Approximately-Optimal Methods with Stability Detection and Switching Behaviors
\begin_inset CommandInset label
LatexCommand label
name "subsec:StabilityDetection"

\end_inset


\end_layout

\begin_layout Standard
In many real-world cases, one may not be able to clearly identify a model
 as drift-stability bound or diffusion-stability bound, or if the equation
 is stiff or non-stiff.
 In fact, many models may switch between such extremes.
 An example is a model with stochastic switching between different steady
 states.
 In this case, we have that the diffusion term 
\begin_inset Formula $f(t,X_{ss})\approx0$
\end_inset

 in the area of many stochastic steady states, meaning that while straddling
 a steady state the integration is heavily diffusion-stability dominated
 and usually non-stiff.
 However, when switching between steady states, 
\begin_inset Formula $f$
\end_inset

 can be very large and stiff, causing the integration to be heavily drift-stabil
ity dominated.
 Since these switches are random, the ability to adapt between these two
 behaviors could be key to achieving optimal performance.
 Given the tradeoff, we investigated how our methods allow for switching
 between methods which optimize for the different situations.
 
\end_layout

\begin_layout Standard
The basis for our method is a straight-forward extension of a method proposed
 for deterministic differential equations.
 The idea is to create a cheap approximation to the dominant eigenvalues
 of the Jacobians for the drift and diffusion terms.
 If 
\begin_inset Formula $v$
\end_inset

 is the eigenvector of the respective Jacobian, then for 
\begin_inset Formula $\Vert v\Vert$
\end_inset

 sufficiently small,
\begin_inset Formula 
\begin{equation}
\left|\lambda_{D}\right|\approx\frac{\Vert f(t,x+v)-f(t,x)\Vert}{\Vert v\Vert},\thinspace\thinspace\thinspace\left|\lambda_{N}\right|\approx\frac{\Vert g(t,x+v)-g(t,x)\Vert}{\Vert v\Vert}\label{eq:eigen}
\end{equation}

\end_inset

 where 
\begin_inset Formula $\left|\lambda_{D}\right|$
\end_inset

 and 
\begin_inset Formula $\left|\lambda_{N}\right|$
\end_inset

 are the estimates of the dominant eigenvalues for the deterministic and
 noise functions respectively.
 We have in approximation that 
\begin_inset Formula $H_{i}^{(k)}$
\end_inset

 is an approximation for 
\begin_inset Formula $X_{t+c_{i}^{(k)}h}$
\end_inset

 and thus the difference between two successive approximations at the same
 timepoint, 
\begin_inset Formula $c_{i}^{(k)}=c_{j}^{(k)}$
\end_inset

, then the following serves as a local Jacobian estimate:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\left|\lambda_{D}\right|\approx\frac{\Vert f(t+c_{i}^{(0)}h,H_{i}^{(0)})-f(t+c_{j}^{(0)}h,H_{j}^{(0)})\Vert}{\Vert H_{i}^{(0)}-H_{j}^{(0)}\Vert},\thinspace\thinspace\thinspace\left|\lambda_{N}\right|\approx\frac{\Vert f(t+c_{i}^{(1)}h,H_{i}^{(1)})-f(t+c_{j}^{(1)}h,H_{j}^{(1)})\Vert}{\Vert H_{i}^{(1)}-H_{j}^{(1)}\Vert}\label{eq:local_eigen}
\end{equation}

\end_inset

 If we had already computed a successful step, we would like to know if
 in the next calculation we should switch methods due to stability.
 Thus it makes sense to approximate the Jacobian at the end of the interval,
 meaning 
\begin_inset Formula $i=s$
\end_inset

 and 
\begin_inset Formula $j=s-1$
\end_inset

 where 
\begin_inset Formula $s$
\end_inset

 is the number of stages.
 Then if 
\begin_inset Formula $z_{min}$
\end_inset

 is the minimum 
\begin_inset Formula $z\in\mathbb{R}$
\end_inset

 such that 
\begin_inset Formula $z$
\end_inset

 is in the stability region for the method, 
\begin_inset Formula $\frac{h\left|\lambda_{D}\right|}{z_{min}}>1$
\end_inset

 when the steps are outside the stability region.
 Because the drift and mixed stability methods do not track the noise axis
 directly, we instead modify 
\begin_inset Formula $w_{min}$
\end_inset

 to be 
\begin_inset Formula $\frac{2}{3}$
\end_inset

 of the maximum of the stability region in the noise axis.
 
\end_layout

\begin_layout Standard
Hairer noted that, for ODEs, if a RK method has 
\begin_inset Formula $c_{i}=c_{j}=1$
\end_inset

, then it follows that
\begin_inset Formula 
\begin{equation}
\rho=\frac{\Vert k_{i}-k_{j}\Vert}{\Vert g_{i}-g_{j}\Vert}\label{eq:rho}
\end{equation}

\end_inset

 where 
\begin_inset Formula $k_{i}=f(t+c_{i}h,g_{i})$
\end_inset

 is an estimate of the eigenvalues for the Jacobian of 
\begin_inset Formula $f$
\end_inset

.
 Given the construction of SRIOpt2, a natural extension is 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\left|\lambda_{D}\right|\approx\frac{\Vert f\left(t_{n}+c_{4}^{(0)}h,H_{4}^{(0)}\right)-f\left(t_{n}+c_{3}^{(0)}h,H_{3}^{(0)}\right)\Vert}{\Vert H_{4}^{(0)}-H_{3}^{(0)}\Vert},\thinspace\thinspace\thinspace\left|\lambda_{N}\right|\approx\frac{\Vert g\left(t_{n}+c_{4}^{(0)}h,H_{4}^{(1)}\right)-g\left(t_{n}+c_{3}^{(0)}h,H_{3}^{(1)}\right)\Vert}{\Vert H_{4}^{(1)}-H_{3}^{(1)}\Vert}\label{eq:sriopt2_eigen}
\end{equation}

\end_inset

Given that these values are all part of the actual step calculations, this
 stiffness estimate is free.
 By comparing these values to the stability plot in Figure X, we use the
 following heristic to decide if SRIOpt2 is stability-bound in its steps:
 
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $10>\left|\lambda_{D}\right|>2.5$
\end_inset

, then we check if 
\begin_inset Formula $h\left|\lambda_{N}\right|>\omega$
\end_inset

.
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $\left|\lambda_{D}\right|<2.5$
\end_inset

, then we check if 
\begin_inset Formula $h\left|\lambda_{N}\right|/2>\omega$
\end_inset

.
\end_layout

\begin_layout Standard
The denominator is chosen as a reasonable approximation to the edge of the
 stability region.
 
\begin_inset Formula $\omega$
\end_inset

 is a safety factor: in theory 
\begin_inset Formula $\omega$
\end_inset

 is 
\begin_inset Formula $1$
\end_inset

 since we divided by the edge of the stability region, but in practice this
 is only an eigenvalue estimate and thus 
\begin_inset Formula $\omega$
\end_inset

 allows for a tradeoff between the false positive and false negative rates.
 If either of those conditions are satisfied, then 
\begin_inset Formula $h$
\end_inset

 is constrained by the stability region.
 The solver can thus alert the user that the method is non-stiff or use
 this estimate to switch to a method more suitable for stiff equations.
 In addition, the error estimator gives separate error estimates in the
 drift and diffusion terms.
 A scheme could combine these two facts to develop a more robust stiffness
 detection method, and label the stiffness as either drift or diffusion
 dominated.
\end_layout

\begin_layout Standard
We end by noting that SOSRA2 has the same property, allowing stiffness detection
 via
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\left|\lambda_{D}\right|\approx\frac{\Vert f\left(t_{n}+c_{3}^{(0)}h,H_{3}^{(0)}\right)-f\left(t_{n}+c_{2}^{(0)}h,H_{2}^{(0)}\right)\Vert}{\Vert H_{3}^{(0)}-H_{2}^{(0)}\Vert}\label{eq:SOSRA_eigen}
\end{equation}

\end_inset

 and, employing a similar method as the deterministic case, check for stiffness
 via the estimate 
\begin_inset Formula $h\left|\lambda_{D}\right|/5>q$
\end_inset

.
\end_layout

\begin_layout Standard
In addition, stiff solvers can measure the maximal eigenvalues directly
 from the Jacobian.
 Here we suggest the measure from Shampine of using 
\begin_inset Formula $\Vert J\Vert_{\infty}$
\end_inset

 as a cheap upper bound.
 For semi-implicit methods like LSRA we only get a stability bound on the
 drift term, but this should be sufficient since for additive noise diffusive
 noise instability is not an issue.
\end_layout

\begin_layout Section
Numerical Results
\end_layout

\begin_layout Subsection
SOSRA Numerical Experiments
\end_layout

\begin_layout Standard
In order to test the efficiency and correctness of the SOSRA algorithms,
 we chose to use the additive noise test equation 
\begin_inset Formula 
\begin{equation}
dX_{t}=\left(\frac{\beta}{\sqrt{1+t}}-\frac{1}{2\left(1+t\right)}X_{t}\right)dt+\frac{\alpha\beta}{\sqrt{1+t}}dW_{t},\thinspace\thinspace\thinspace X_{0}=\frac{1}{2},\label{eq:ex3}
\end{equation}

\end_inset

 where 
\begin_inset Formula $\alpha=\frac{1}{10}$
\end_inset

 and 
\begin_inset Formula $\beta=\frac{1}{20}$
\end_inset

.
 Actual Solution:
\begin_inset Formula 
\begin{equation}
X_{t}=\frac{1}{\sqrt{1+t}}X_{0}+\frac{\beta}{\sqrt{1+t}}\left(t+\alpha W_{t}\right).\label{eq:sol3}
\end{equation}

\end_inset

 To test the efficiency we plotted a work-precision diagram against the
 SRA1, SRA2, SRA3, and the fixed timestep Euler-Maruyama and a Runge-Kutta
 Milstein scheme.
 The results show that there is a minimal difference in efficiency between
 the SRA algorithms for errors in the interval 
\begin_inset Formula $\left[10^{-6},10^{-2}\right]$
\end_inset

, while these algorithms are all siginificantly more efficient than the
 lower order algorithms when the required error is 
\begin_inset Formula $<10^{-4}$
\end_inset

 (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:SOSRI-Stability-Regions."

\end_inset

).
 To show that the SOSRA methods indeed achieve the appropriate strong order,
 a convergence test was conducted and it was shown that four separate measures
 of error converged at a rate 2.0 (it has previously been noted that SRA
 methods have a higher convergence rate, at least on this problem.
 The authors have noticed this phonomena elsewere as well).
 These results show that in the regime of mild accuracy, these methods are
 much more efficient than low order methods yet achieve the same efficiency
 as the non-stability optimized SRA variants (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:SOSRA-efficiency-and"

\end_inset

).
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/Chris/.julia/v0.6/SRKGenerator/assets/paper_figures/SRA_efficiency.pdf
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
SOSRA efficiency and correctness tests.
 
\series bold
(A)
\series default
 Shown are the work-precision plots for the methods on the additive noise
 test problem.
 Each of the adaptive timestepping methods solved the problem on the interval
 using changing values of tolerances, with 
\begin_inset Formula $tol=abstol=reltol$
\end_inset

 starting at 
\begin_inset Formula $10^{2}$
\end_inset

 and ending at 
\begin_inset Formula $10^{-4}$
\end_inset

 going in increments of 
\begin_inset Formula $10$
\end_inset

.
 The fixed timestepping methods used timesteps of size 
\begin_inset Formula $h=1/5^{-1}$
\end_inset

 to 
\begin_inset Formula $h=1/5^{4}$
\end_inset

, changing the value by factors of 
\begin_inset Formula $5$
\end_inset

.
 The error is the strong 
\begin_inset Formula $l_{2}$
\end_inset

 error computed over the timeseries.
 The time is the avarage time to compute a trajectory and is averaged over
 1000 runs at the same tolerance / timestep size.
 
\series bold
(B) 
\series default
Depicted are the results of a convergence test on the SOSRA and SOSRA2 methods.
 The test used a fixed timestep 
\begin_inset Formula $h=1/2^{-2}$
\end_inset

 to 
\begin_inset Formula $h=1/2^{-10}$
\end_inset

.
 Shown are four separate error estimates: the strong 
\begin_inset Formula $l_{\infty}$
\end_inset

 error, the strong 
\begin_inset Formula $l_{2}$
\end_inset

 error, the weak error at the final timepoint, and the strong error at the
 final timepoint.
 The strong error is averaged over 10 trajectories, which is the same number
 of trajectories used to compute the weak error estimate.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:SOSRA-efficiency-and"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To test how efficiently the algorithms could achieve their goal, we choose
 to analyze the qualtative results of the driven Van der Pol equation.
 The driven Van der Pol equation is given by the system:
\begin_inset Formula 
\begin{align*}
dy & =μ((1-x^{2})y-x)dt\\
dx & =ydt
\end{align*}

\end_inset

 where 
\begin_inset Formula $\mu$
\end_inset

 is the driving factor.
 As 
\begin_inset Formula $\mu$
\end_inset

 increases the equation becomes more stiff.
 
\begin_inset Formula $\mu=10^{6}$
\end_inset

 is a common test for stiff ODE solvers, with lower values used to test
 the semi-stiff regime for ODEs.
 For our purposes, we chose 
\begin_inset Formula $\mu=10^{5}$
\end_inset

 as a semi-stiff test case.
 The ODE case, solved using the Tsit5 explicit Runge-Kutta algorithm, and
 demonstrates the mild stiffness which is still well-handled by explicit
 methods (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:AdditiveVanDerPol"

\end_inset

A).
 We extend this model to the driven Van der Pol model with additive noise:
\begin_inset Formula 
\begin{align*}
dy & =μ((1-x^{2})y-x)dt+\rho dW_{t}^{(1)}\\
dx & =y+\rho dW_{t}^{(2)}
\end{align*}

\end_inset

where 
\begin_inset Formula $\rho=3.0$
\end_inset

 is the noise gain and 
\begin_inset Formula $dW^{(1)}$
\end_inset

 and 
\begin_inset Formula $dW^{(2)}$
\end_inset

 are independent Brownian motions.
 The solution to this model is interesting because it gives the same qualitative
 behavior, large bursts when 
\begin_inset Formula $x(t)$
\end_inset

 crosses zero, but in this case the zero crossings are stochastic.
 Even at high tolerances, (
\begin_inset Formula $abstol=10$
\end_inset

,
\begin_inset Formula $reltol=1/2^{1}$
\end_inset

), SOSRA is able to reproduce this qualitative behavior (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:AdditiveVanDerPol"

\end_inset

B), and SOSRA2 producing similar results at the same tolerances a factor
 of two lower.
 However, even at tolerances of 
\begin_inset Formula $abstol=1/2^{3}$
\end_inset

,
\begin_inset Formula $reltol=1/2^{3}$
\end_inset

 SRA3 was unable to reproduce the correct qualitative behavior (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:AdditiveVanDerPol"

\end_inset

C).
 Thus we decreased the tolerances by factors of 2 until it was able to reproduce
 the correct qualitative results (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:AdditiveVanDerPol"

\end_inset

D).
 This shows that the SOSRA are more reliable on models with transient stiffness.
 To test the impact on the runtime of the algorithms, each of the algorithms
 were run 100 times with the tolerance setup that allows them to most efficientl
y generate correct qualitative results.
 The runtimes are shown in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:SRA-Runtimes-on-Van"

\end_inset

, which show that SRA1 takes nearly 5 times and SRA3 nearly 4 times as long
 as the SOSRA methods to generate a correct result.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Algorithm
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Runtime
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Relative Time (vs SOSRA)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SOSRA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
520.054837
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SOSRA2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
520.847214
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.002x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SRA1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2488.683401
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.785x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SRA3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2033.
 793730
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.911x
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
SRA Runtimes on Van der Pol with additive noise.
 The additive noise Van der Pol equation was solved 100 times using the
 respective algorithms.
\begin_inset CommandInset label
LatexCommand label
name "tab:SRA-Runtimes-on-Van"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/Chris/.julia/v0.6/SRKGenerator/assets/paper_figures/additive_vanderpol.pdf
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Representative trajectories for solutions to the Van der Pol equations with
 additive noise.
 
\series bold
(A)
\series default
 The solution to the ODE with the explicit Runge-Kutta method Tsit5.
 
\series bold
(B) 
\series default
The solution to the SDE with tolerance 
\begin_inset Formula $abstol=1,reltol=1/2^{1}$
\end_inset

 from SOSRA.
 
\series bold
(C) 
\series default
Solution to the SDE with tolerances 
\begin_inset Formula $abstol=2^{-3},reltol=2^{-3}$
\end_inset

 with SRA3.
 
\series bold
(D) 
\series default
Solution to the SDE with tolerances 
\begin_inset Formula $abstol=2^{-6},reltol=2^{-4}$
\end_inset

 with SRA3.
\begin_inset CommandInset label
LatexCommand label
name "fig:AdditiveVanDerPol"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In addition to testing efficiency, we used this to test the stiffness detection
 in SOSRA2.
 Using a safety factor of 
\begin_inset Formula $\omega=5$
\end_inset

, we added only two lines of code to make the algorithm print out the timings
 for which the algorithm predicts stiffness.
 The results on two trajectories were computed (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Stiffness-detection-in-additive"

\end_inset

).
 The authors note that the algorithms are surprisingly robust without any
 tweaking being done and are shown to not give almost any false positives
 nor false negatives on this test problem.
 While this safety factor is set somewhat high in comparison to traditional
 ODE stiffness detection, we note that these algorithms were designed to
 efficiently handle mild stiffness and thus we see it as a benefit that
 they only declare stiffness when it appears to be in the regime which is
 more suitable for implicit methods.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/Chris/.julia/v0.6/SRKGenerator/assets/paper_figures/sde_stiffness_detection.pdf
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Stiffness detection in the Van der Pol equations with additive noise.
 Two representative trajectories to the Van der Pol equations are plotted.
 The green dots indicate timepoints where the stiffness detection algorithm
 detected stiffness.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Stiffness-detection-in-additive"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
SOSRI Numerical Experiments
\end_layout

\begin_layout Standard
In order to test the efficiency and correctness of the SOSRI algorithms,
 we chose to use the scalar noise test equation 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
dX_{t}=\alpha X_{t}dt+\beta X_{t}dW_{t}\thinspace\thinspace\thinspace X_{0}=\frac{1}{2},\label{eq:ex1}
\end{equation}

\end_inset

where 
\begin_inset Formula $\alpha=\frac{1}{10}$
\end_inset

 and 
\begin_inset Formula $\beta=\frac{1}{20}$
\end_inset

.
 Actual Solution:
\begin_inset Formula 
\begin{equation}
X_{t}=X_{0}e^{\left(\beta-\frac{\alpha^{2}}{2}\right)t+\alpha W_{t}}.\label{eq:sol1}
\end{equation}

\end_inset

To test the efficiency we plotted a work-precision diagram against the SRIW1,
 SOSRI, SOSRI2, and the fixed timestep Euler-Maruyama and a Runge-Kutta
 Milstein schemes.
 The results show that there is a minimal difference in efficiency between
 the SRI algorithms for errors over the interval 
\begin_inset Formula $\left[10^{-6},10^{-2}\right]$
\end_inset

, while these algorithms are all siginificantly more efficient than the
 lower order algorithms when the required error is 
\begin_inset Formula $<10^{-2}$
\end_inset

 (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:SOSRI-efficiency-and"

\end_inset

A).
 To show that the SOSRA methods indeed achieve the appropriate strong order,
 a convergence test was conducted and it was shown that four separate measures
 of error converged at a rate 1.5 (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:SOSRI-efficiency-and"

\end_inset

B).
 These results show that in the regime of mild accuracy, these methods are
 much more efficient than low order methods yet achieve the same efficiency
 as the non-stability optimized SRI variants.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/Chris/.julia/v0.6/SRKGenerator/assets/paper_figures/SOSRI_efficiency_convergence.pdf
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
SOSRI efficiency and correctness tests.
 
\series bold
(A)
\series default
 Shown are the work-precision plots for the methods on the scalar noise
 test problem.
 Each of the adaptive timestepping methods solved the problem on the interval
 using changing values of tolerances, with 
\begin_inset Formula $tol=abstol=reltol$
\end_inset

 starting at 
\begin_inset Formula $10^{-1}$
\end_inset

 and ending at 
\begin_inset Formula $10^{-5}$
\end_inset

 going in increments of 
\begin_inset Formula $10$
\end_inset

.
 The fixed timestepping methods used timesteps of size 
\begin_inset Formula $h=1/5^{-3}$
\end_inset

 to 
\begin_inset Formula $h=1/5^{8}$
\end_inset

, changing the value by factors of 
\begin_inset Formula $5$
\end_inset

.
 The error is the strong 
\begin_inset Formula $l_{2}$
\end_inset

 error computed over the timeseries.
 The time is the avarage time to compute a trajectory and is averaged over
 1000 runs at the same tolerance / timestep size.
 
\series bold
(B) 
\series default
Depicted are the results of a convergence test on the SOSRA and SOSRA2 methods.
 The test used a fixed timestep 
\begin_inset Formula $h=1/2^{-2}$
\end_inset

 to 
\begin_inset Formula $h=1/2^{-10}$
\end_inset

.
 Shown are four separate error estimates: the strong 
\begin_inset Formula $l_{\infty}$
\end_inset

 error, the strong 
\begin_inset Formula $l_{2}$
\end_inset

 error, the weak error at the final timepoint, and the strong error at the
 final timepoint.
 The strong error is averaged over 10 trajectories, which is the same number
 of trajectories used to compute the weak error estimate.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:SOSRI-efficiency-and"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To test the real consequences of the enhanced stability, we use the Oval2
 model of 19 pathwise stiff reaction equations introduced in X and studied
 as a numerical test in Y.
 In the previous work it was noted that 
\begin_inset Formula $t\in\left[0,1\right]$
\end_inset

 was a less stiff version of this model over the timespan 
\begin_inset Formula $t\in\left[0,500\right]$
\end_inset

.
 Thus we first tested the speed that the methods could solve for 10,000
 trajectories with no failures due to numerical instabilities.
 The tolerances were tuned for each method by factors of 2 and finding the
 largest values that were stable.
 In order to test the raw efficiency of the methods, we used the same tableau-ba
sed implementation and only replaced the coefficients.
 Since SOSRI demonstrated that its stability is much higher than even SOSRI2,
 we show the effect of tolerance changes on SOSRI as well.
 The results show that at similar tolerances the SRI methods take nearly
 the same amount of time (Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:SRI-times-for-Oval2"

\end_inset

).
 However, there is an upper bound on the tolerances before the adaptivity
 is no longer able to help keep the method stable.
 For SRIW1, this bound is much lower, causing it to run more than 15x slower
 than the fastest SOSRI setup.
 We note that this relative tolerance 
\begin_inset Formula $2^{-18}\approx3.9\times10^{-6}$
\end_inset

 is essentially requiring 6 digits of accuracy (in strong error), which
 is far beyond the accuracy necessary in many cases.
 Instead, SOSRI can achieve around 2 digits of accuracy in each trajectory
 in a time that is an order of magnitude faster.
 Since weak order is higher and weak error is usually lower, this represents
 more than enough accuracy to adequately solve the problem and get good
 measurements of moments.
 We note that the maximal tolerances which is stable for SOSRI2 is lower
 than that for SOSRI, meaning that it is able to handle less stiff problems
 as well, but note that it includes a stiffness detection algorithm similar
 to SOSRA2 and thus tradeoff some stiffness handling for the ability to
 switch to other algorithms when stiff.
 We note that timings for Euler-Mauyama and Runge-Kutta Milstein schemes
 are omitted since the tests were unable to finish.
 From the results of CITE we note that the average 
\begin_inset Formula $dt$
\end_inset

 for SRIW1 on the edge of its stability had that the smallest 
\begin_inset Formula $dt$
\end_inset

 was approximately 
\begin_inset Formula $10^{-11}$
\end_inset

.
 The stability region for fixed stepsize Euler-Maruyama is strictly smaller
 than SRIW1 and thus would require around 
\begin_inset Formula $5\times10^{12}$
\end_inset

 timesteps (with Runge-Kutta Milstein being similar) to solve to 
\begin_inset Formula $t=500$
\end_inset

 (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:SOSRI-Stability-Regions."

\end_inset

).
 Thus, given it takes on our setup extrapolating the time given 170 seconds
 for 
\begin_inset Formula $2^{20}$
\end_inset

 steps, this projects to around 
\begin_inset Formula $1.6\times10^{8}$
\end_inset

 seconds, or approximately 5 years.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Algorithm
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Abstol
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reltol
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Runtime
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Relative Time (vs SOSRI)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SOSRI
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2^{-7}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2^{-4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.456220255
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SOSRI
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2^{-7}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2^{-6}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.528014259
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.02x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SOSRI
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2^{-12}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2^{-15}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15.154482346
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.401x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SOSRI
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2^{-14}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2^{-18}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64.385613115
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14.45x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SOSRI2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2^{-12}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2^{-15}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15.465410168
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.471x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SOSRI2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2^{-14}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2^{-18}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
63.918306532
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14.34x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SRIW1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2^{-14}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2^{-18}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
68.196888282
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15.30x
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
SRI times for the the Oval2 model on 
\begin_inset Formula $t\in\left[0,1\right]$
\end_inset

.
 The equations were solve 10,000 times with the given tolerances to completion
 and the elapsed time was recorded.
\begin_inset CommandInset label
LatexCommand label
name "tab:SRI-times-for-Oval2"

\end_inset

 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We then timed the runtime to solve 10 trajectories in the 
\begin_inset Formula $t\in\left[0,500\right]$
\end_inset

 case (Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:SRI-times-for-Oval2-long"

\end_inset

).
 This time we found the optimal tolerance in terms of powers of 
\begin_inset Formula $10$
\end_inset

.
 Once again, SRIW1 needed a lower tolerance than is necessary in order to
 stay stable.
 SOSRI is able to solve the problem only asking for 2 digits of accuracy,
 while the others require more (especially in absolute tolerance as there
 is a stiff reactant whose values travel close to zero).
 One interesting point to note is that at similar tolerances both SOSRI
 and SOSRI2 receive similar timings again, and both are nearly twice as
 fast as SRIW1 when matching tolerances.
 
\end_layout

\begin_layout Standard
As another test we applied the methods to a method of lines (MOL) discretization
 of a stochastic partial differential equation (SPDE) describing the spatial
 regulation of the zebrafish hindbrain via retinoic acid signaling (CITE).
 The model was solved nearly to steady state using a second order Rosenbrock
 method on the PDE described by the drift term.
 Starting from steady state, noise was added to the gradient by solving
 the extension to an SPDE with multiplicative noise on 
\begin_inset Formula $t\in\left[0,50\right]$
\end_inset

.
 Each of the methods solved the problem at the highest tolerance possible
 and the timings (Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:SRI-times-for-SPDE"

\end_inset

).
 Since this problem starts from the only positive steady state, it is only
 semi-stiff.
 Yet we receieve similar results as the other problems, signaling that the
 expanded stability domain can lead to speedups against other high order
 SRK methods even to equations which only exhibit slight amounts of stiffness.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Algorithm
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Abstol
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reltol
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Runtime
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Relative Time (vs SOSRI)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SOSRI
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{-2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{-2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
42.278439
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SOSRI
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{-4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{-4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
127.546408
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.017x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SOSRI
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{-5}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{-3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
161.754319
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.826x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SOSRI2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{-4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{-4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
133.714578
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.163x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SOSRI2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{-5}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{-3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
189.233673
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.163x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SRIW1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{-5}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{-3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
357.097802
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8.446x
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
SRI times for the the Oval2 model on 
\begin_inset Formula $t\in\left[0,500\right]$
\end_inset

.
 The equations were solve 10,000 times with the given tolerances to completion
 and the elapsed time was recorded.
 
\begin_inset CommandInset label
LatexCommand label
name "tab:SRI-times-for-Oval2-long"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Algorithm
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Abstol
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reltol
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Runtime
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Relative Time (vs SOSRI)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SOSRI
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{-1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{-1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4150.078598
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SOSRI2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{-1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{-1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17563.2690785
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.232x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SRIW1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{-5}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10^{-3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
41407.3344385
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9.977x
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
SRI times for the the RA SPDE model on 
\begin_inset Formula $t\in\left[0,50\right]$
\end_inset

.
 The equations were solved twice with the given tolerances to completion
 and the elapsed time was recorded.
 Note that none of the timings varied by more than 1% of the total runtime.
 
\begin_inset CommandInset label
LatexCommand label
name "tab:SRI-times-for-SPDE"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Standard
In this work we derived stability-optimized SRK methods for additive and
 diagonal noise equations, and used a transformation to allow the additive
 noise methods to solve affine noise problems.
 Many other equations can be reduced to the additive noise case as well
 using the same means.
 Importantly, our derivation methods utilized heavy computational tools
 in order to approximately optimize otherwise intractable equations.
 This same method of derivation can easily be scaled up to higher orders,
 and by incorporating the coefficients for higher conditions, efficiency
 can be optimized as well by adding the norm of the principle error coefficients
 to the optimization function.
 We note that the majority of the search was performed using global optimizers
 in massive parallel using a hand-optimized CUDA kernal for the numerical
 integral of the characteristic function, replacing man-hours with core-hours
 and effectively optimizing the method.
 The clear next steps are to find SRA and SRI methods with minimal error
 estimates and sensible stability regions for the cases in which lower strong
 error matters, and similar optimizations on SRK methods developed for weak
 noise estimation.
 We note that high strong order methods were investigated because of their
 better trajectory-wise convergence, allowing for a more robust solution
 and error estimation since our application to transiently pathwise stiff
 equations requires such properties.
\end_layout

\begin_layout Standard
In this work we also derived L stable methods for additive (and thus multiplicat
ive) noise equations, and computationally could not find an A-B-L stable
 method.
 While our method does not prove that no 2-stage A-B-L method exists, we
 have at least drastically narrowed down its possibility.
 Additionally an extension of a well-known ESDIRK method to additive noise
 was developed.
 We note that the stability analysis here only applies to additive noise
 and thus will likely not extend well to diagonal noise.
\end_layout

\begin_layout Standard
Our timings convincingly show that the current high order SRK methods are
 stability-bound and that when scientific studies are only looking for small
 amounts of accuracy in stochastic simulations, most of the computational
 effort is lost to generating more accurate than neccessary solutions in
 order to satisfy stability constraints.
 For additive noise problems we were able to obtain solutions about 4x faster
 and for diagonal noise 8x-15x than the current methods (SRA1, SRA3, SRIW1).
 We note that the popular Euler-Maruyama and (derivative-free) Milstein
 methods were previously compared in X and were shown to be more than 12x
 slower than the SRIW1 method on the Oval2 model for 
\begin_inset Formula $t\in\left[0,1\right]$
\end_inset

 and is thus a large improvement over what's available in most software.
 We have also shown that these methods are very robust even at high tolerances
 and have a tendency to produce the correct qualitative results (via plots)
 even when the user chosen accuracy is low.
 Given that the user input is minimal, we see these as very strong candidates
 for general purpose solvers for problem-solving environments such as MATLAB
 and Julia since they can easily and efficiently produce results which are
 sufficiently correct.
 We note that these methods are not efficient at low tolerances, and other
 methods such as SRA3 (or higher order SRK methods) should be used instead.
 However, in many cases like integrating to find steady distributions of
 bistable parameter regimes, this ability to quickly get a more course estimate
 is valuable.
\end_layout

\begin_layout Standard
We note that the stiffness detection in SDEs is a novel addition which we
 have demonstrated can act very robustly.
 It has a control parameter 
\begin_inset Formula $\omega$
\end_inset

 which can be used to control the false positive and false negative rate
 as needed.
 Note that stiff methods can achieve similar largest eigenvalue estimates
 directly from the Jacobians of 
\begin_inset Formula $f$
\end_inset

 (and 
\begin_inset Formula $g$
\end_inset

) given that the methods are implicit (or in the case of Rosenbrock methods,
 the Jacobian must still be computed), and thus this can be paired with
 a stiff solver to allow for automatic switching between stiff and nonstiff
 solvers.
 Given that the cost for such stiffness checks is minimal, we are interested
 in future studies on the efficiency of such methods due to the stochastic
 nature of stiffness in SDEs.
\end_layout

\begin_layout Section
Appendix I: SRK Order Conditions 
\end_layout

\begin_layout Subsection
Order Conditions for Rößler-SRI Methods
\begin_inset CommandInset label
LatexCommand label
name "subsec:Order-Conditions-for-SRI"

\end_inset


\end_layout

\begin_layout Standard
The coefficients 
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\left(A_{0},B_{0},\beta^{(i)},\alpha\right)$
\end_inset

 must satisfy the following order conditions to achieve order .5:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{multicols}{3}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\alpha^{T}e=1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\beta^{(1)^{T}}e=1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\beta^{(2)^{T}}e=0$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\beta^{(3)^{T}}e=0$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\beta^{(4)^{T}}e=0$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{multicols}
\end_layout

\end_inset

 additionally, for order 1:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{multicols}{2}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\beta^{(1)^{T}}B^{(1)}e=0$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\beta^{(2)^{T}}B^{(1)}e=1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\beta^{(3)^{T}}B^{(1)}e=0$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\beta^{(4)^{T}}B^{(1)}e=0$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{multicols}
\end_layout

\end_inset

 and lastly for order 1.5:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{multicols}{2}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\alpha^{T}A^{(0)}e=\frac{1}{2}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\alpha^{T}B^{(0)}e=1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\alpha^{T}\left(B^{(0)}e\right)^{2}=\frac{3}{2}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\beta^{(1)^{T}}A^{(1)}e=1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\beta^{(2)^{T}}A^{(1)}e=0$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\beta^{(3)^{T}}A^{(1)}e=-1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\beta^{(4)^{T}}A^{(1)}e=0$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\beta^{(1)^{T}}\left(B^{(1)}e\right)^{2}=1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\beta^{(2)^{T}}\left(B^{(1)}e\right)^{2}=0$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\beta^{(3)^{T}}\left(B^{(1)}e\right)^{2}=-1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\beta^{(4)^{T}}\left(B^{(1)}e\right)^{2}=2$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\beta^{(1)^{T}}\left(B^{(1)}\left(B^{(1)}e\right)\right)=0$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\beta^{(2)^{T}}\left(B^{(1)}\left(B^{(1)}e\right)\right)=0$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\beta^{(3)^{T}}\left(B^{(1)}\left(B^{(1)}e\right)\right)=0$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\beta^{(4)^{T}}\left(B^{(1)}\left(B^{(1)}e\right)\right)=1$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{multicols}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[ ]
\end_layout

\end_inset


\begin_inset Formula 
\[
16.\thinspace\thinspace\thinspace\frac{1}{2}\beta^{(1)^{T}}\left(A^{(1)}\left(B^{(0)}e\right)\right)+\frac{1}{3}\beta^{(3)^{T}}\left(A^{(1)}\left(B^{(0)}e\right)\right)=0
\]

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $f,g\in C^{1,2}(\mathcal{I}\times\mathbb{R}^{d},\mathbb{R}^{d})$
\end_inset

, 
\begin_inset Formula $c^{(i)}=A^{(i)}e$
\end_inset

, 
\begin_inset Formula $e=(1,1,1,1)^{T}$
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "RN2707"

\end_inset

.
 
\end_layout

\begin_layout Subsection
Order Conditions for Rößler-SRA Methods
\begin_inset CommandInset label
LatexCommand label
name "subsec:Order-Conditions-for-SRA"

\end_inset


\end_layout

\begin_layout Standard
The coefficients
\begin_inset Newline newline
\end_inset

 
\begin_inset Formula $\left(A_{0},B_{0},\beta^{(i)},\alpha\right)$
\end_inset

 must satisfy the conditions for order 1:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{multicols}{3}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\alpha^{T}e=1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\beta^{(1)^{T}}e=1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\beta^{(2)^{T}}e=0$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{multicols}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and the additional conditions for order 1.5:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{multicols}{3}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\alpha^{T}B^{(0)}e=1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\alpha^{T}A^{(0)}e=\frac{1}{2}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\alpha^{T}\left(B^{(0)}e\right)^{2}=\frac{3}{2}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\beta^{(1)^{T}}c^{(1)}=1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\beta^{(2)^{T}}c^{(1)}=-1$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{multicols}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $c^{(0)}=A^{(0)}e$
\end_inset

 with 
\begin_inset Formula $f\in C^{1,3}(\mathcal{I}\times\mathbb{R}^{d},\mathbb{R}^{d})$
\end_inset

 and 
\begin_inset Formula $g\in C^{1}(\mathcal{I},\mathbb{R}^{d})$
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "RN2707"

\end_inset

.
 From these conditions he proposed the following Strong Order 1.5 scheme
 known as SRA1:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begingroup
\backslash
tabcolsep=8pt
\backslash
def
\backslash
arraystretch{2}
\end_layout

\end_inset


\size small

\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $c^{(0)}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A^{(0)}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $B^{(0)}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\alpha^{T}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\beta^{(1)^{T}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\beta^{(2)^{T}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\size default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
endgroup
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begingroup
\backslash
tabcolsep=6pt
\backslash
def
\backslash
arraystretch{2}
\end_layout

\end_inset


\size footnotesize

\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="7">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\frac{3}{4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\frac{3}{4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\frac{1}{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\frac{1}{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\frac{2}{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
-1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\size default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
endgroup
\end_layout

\end_inset


\end_layout

\begin_layout Section
Appendix II: Derivation Details
\end_layout

\begin_layout Standard

\size tiny
\begin_inset Formula 
\begin{eqnarray*}
\left(I-\mu\Delta tA^{(0)}\right)H^{(0)} & = & U_{n}+\sigma\frac{I_{(1,0)}}{\Delta t}B^{(0)}\left(I-\sigma\sqrt{\Delta t}B^{(1)}\right)^{-1}\left(U_{n}+\mu\Delta tA^{(1)}H^{(0)}\right),\\
\left(I-\mu\Delta tA^{(0)}\right)H^{(0)}-\left[\sigma\frac{I_{(1,0)}}{\Delta t}B^{(0)}\left(I-\sigma\sqrt{\Delta t}B^{(1)}\right)^{-1}\right]\mu\Delta tA^{(1)}H^{(0)} & = & U_{n}+\sigma\frac{I_{(1,0)}}{\Delta t}B^{(0)}\left(I-\sigma\sqrt{\Delta t}B^{(1)}\right)^{-1}U_{n}\\
\left(I-\mu\Delta tA^{(0)}-\mu\Delta tA^{(1)}\sigma\frac{I_{(1,0)}}{\Delta t}B^{(0)}\left(I-\sigma\sqrt{\Delta t}B^{(1)}\right)^{-1}\right)H^{(0)} & = & \left(I+\sigma\frac{I_{(1,0)}}{\Delta t}B^{(0)}\left(I-\sigma\sqrt{\Delta t}B^{(1)}\right)^{-1}\right)U_{n}\\
H^{(0)} & = & \left(I-\mu\Delta tA^{(0)}-\mu\sigma I_{(1,0)}A^{(1)}B^{(0)}\left(I-\sigma\sqrt{\Delta t}B^{(1)}\right)^{-1}\right)^{-1}\\
 &  & \left(I+\sigma\frac{I_{(1,0)}}{\Delta t}B^{(0)}\left(I-\sigma\sqrt{\Delta t}B^{(1)}\right)^{-1}\right)U_{n}
\end{eqnarray*}

\end_inset


\begin_inset Formula 
\begin{eqnarray*}
\left(I-\sigma\sqrt{\Delta t}B^{(1)}\right)H^{(1)} & = & U_{n}+\mu\Delta tA^{(1)}\left(I-\mu\Delta tA^{(0)}\right)^{-1}\left(U_{n}+\sigma\frac{I_{(1,0)}}{\Delta t}B^{(0)}H^{(1)}\right)\\
\left(I-\sigma\sqrt{\Delta t}B^{(1)}-\mu\Delta tA^{(1)}\left(I-\mu\Delta tA^{(0)}\right)^{-1}\sigma\frac{I_{(1,0)}}{\Delta t}B^{(0)}\right)H^{(1)} & = & U_{n}+\mu\Delta tA^{(1)}\left(I-\mu\Delta tA^{(0)}\right)^{-1}U_{n}\\
\left(I-\sigma\sqrt{\Delta t}B^{(1)}-\mu\Delta tA^{(1)}\left(I-\mu\Delta tA^{(0)}\right)^{-1}\sigma\frac{I_{(1,0)}}{\Delta t}B^{(0)}\right)H^{(1)} & = & \left(I+\mu\Delta tA^{(1)}\left(I-\mu\Delta tA^{(0)}\right)^{-1}\right)U_{n}\\
H^{(1)} & = & \left(I-\sigma\sqrt{\Delta t}B^{(1)}-\mu\Delta tA^{(1)}\left(I-\mu\Delta tA^{(0)}\right)^{-1}\sigma\frac{I_{(1,0)}}{\Delta t}B^{(0)}\right)^{-1}\\
 &  & \left(I+\mu\Delta tA^{(1)}\left(I-\mu\Delta tA^{(0)}\right)^{-1}\right)U_{n}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard

\size tiny
\begin_inset Formula 
\begin{eqnarray*}
U_{n+1} & = & U_{n}+\mu\Delta t\left(\alpha\cdot\left[\left(I-\mu\Delta tA^{(0)}-\mu\sigma I_{(1,0)}A^{(1)}B^{(0)}\left(I-\sigma\sqrt{\Delta t}B^{(1)}\right)^{-1}\right)^{-1}\left(I+\sigma\frac{I_{(1,0)}}{\Delta t}B^{(0)}\left(I-\sigma\sqrt{\Delta t}B^{(1)}\right)^{-1}\right)\right]U_{n}\right)\\
 &  & +\sigma I_{(1)}\left(\beta^{(1)}\cdot\left[\left(I-\sigma\sqrt{\Delta t}B^{(1)}-\mu\Delta tA^{(1)}\left(I-\mu\Delta tA^{(0)}\right)^{-1}\sigma\frac{I_{(1,0)}}{\Delta t}B^{(0)}\right)^{-1}\left(I+\mu\Delta tA^{(1)}\left(I-\mu\Delta tA^{(0)}\right)^{-1}\right)\right]U_{n}\right)\\
 &  & +\sigma\frac{I_{(1,1)}}{\sqrt{\Delta t}}\left(\beta^{(2)}\cdot\left[\left(I-\sigma\sqrt{\Delta t}B^{(1)}-\mu\Delta tA^{(1)}\left(I-\mu\Delta tA^{(0)}\right)^{-1}\sigma\frac{I_{(1,0)}}{\Delta t}B^{(0)}\right)^{-1}\left(I+\mu\Delta tA^{(1)}\left(I-\mu\Delta tA^{(0)}\right)^{-1}\right)\right]U_{n}\right)\\
 &  & +\sigma\frac{I_{(1,0)}}{\Delta t}\left(\beta^{(3)}\cdot\left[\left(I-\sigma\sqrt{\Delta t}B^{(1)}-\mu\Delta tA^{(1)}\left(I-\mu\Delta tA^{(0)}\right)^{-1}\sigma\frac{I_{(1,0)}}{\Delta t}B^{(0)}\right)^{-1}\left(I+\mu\Delta tA^{(1)}\left(I-\mu\Delta tA^{(0)}\right)^{-1}\right)\right]U_{n}\right)\\
 &  & +\sigma\frac{I_{(1,1,1)}}{\Delta t}\left(\beta^{(4)}\cdot\left[\left(I-\sigma\sqrt{\Delta t}B^{(1)}-\mu\Delta tA^{(1)}\left(I-\mu\Delta tA^{(0)}\right)^{-1}\sigma\frac{I_{(1,0)}}{\Delta t}B^{(0)}\right)^{-1}\left(I+\mu\Delta tA^{(1)}\left(I-\mu\Delta tA^{(0)}\right)^{-1}\right)\right]U_{n}\right)
\end{eqnarray*}

\end_inset


\size default
 Thus we substitute in the Wiktorsson approximations
\begin_inset Formula 
\begin{align*}
I_{(1,1)} & =\frac{1}{2}\left(\Delta W^{2}-h\right)\\
I_{(1,1,1)} & =\frac{1}{6}\left(\Delta W^{3}-3h\Delta W\right)\\
I_{(1.0)} & =\frac{1}{2}h\left(\Delta W+\frac{1}{\sqrt{3}}\Delta Z\right)
\end{align*}

\end_inset

 where 
\begin_inset Formula $\Delta Z\sim N(0,h)$
\end_inset

 is independent of 
\begin_inset Formula $\Delta W\sim N(0,h)$
\end_inset

.
 By the properties of the normal distribution, we have that
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
E\left[\left(\Delta W\right)^{n}\right]=0
\]

\end_inset

 for any odd 
\begin_inset Formula $n$
\end_inset

 and
\begin_inset Formula 
\begin{eqnarray*}
E\left[\left(\Delta W\right)^{2}\right] & = & h\\
E\left[\left(\Delta W\right)^{4}\right] & = & 3h^{2}\\
E\left[\left(\Delta W\right)^{6}\right] & = & 15h^{3}\\
E\left[\left(\Delta W\right)^{8}\right] & = & 105h^{4}.
\end{eqnarray*}

\end_inset


\end_layout

\end_body
\end_document
